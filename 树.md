#树
分层次组织在管理上具有更高的效率！
数据管理的基本操作之一：查找
1.静态查找：纪录是固定的。2.动态查找：纪录是动态变化的（插入，删除）。
##1.树的表示方法：链表。儿子兄弟表示法
##2.二叉树T：一个有穷的节点集合。由根节点和称为其左子树和右子树的两个不想叫得二叉树组成。
###2.1二叉树的存储结构。
####2.1.1顺序存储结构
完全二叉树：按从上之下，从左到右顺序存储
####2.1.2链式存储结构
    typedef struct TreeNode *BinTree;
    typedef BinTree Position;
    struct TreeNode{
      ElementType Data;
      BInTree Left;
      BinTree Right;
    }
####2.1.2二叉树的遍历
(1)先序遍历

    void PreOrderTraversal(BinTree BT){
      if(BT){
        printf("%d",BT->Data);
        PreOrderTraversal(BT->Left);
        PreOrderTraversal(BT->Right);
      }
    }  
(2)中序遍历

    void InOrderTraversal(BinTree BT){
      if(BT){
        InOrderTraversal(BT->Left);
        printf("%d",BT->Data);
        InOrderTraversal(BT->Right);
      }
    }
(3)后序遍历

    void PostOrderTraversal(BinTree BT){
      if(BT){
        PreOrderTraversal(BT->Left);  
        PreOrderTraversal(BT->Right);
        printf("%d",BT->Data);
      }
    }
(4)中序遍历非递归

    void InOrderTraversal(BinTree BT){
      BinTree T=BT;
      Stack s = CreateStack(MaxSize);
      while(T || !IsEmpty(S)){
        while(T){ /*一直向左并将沿途结点压入堆栈*/
          Push(S,T);
          T=T->Left;
        }
        if(!IsEmpty(S)){
          T=Pop(s); /*结点弹出堆栈*/
          printf("%d",T->Data); /*（访问）打印节点*/
          T=T->Right; /*转向右子树*/
        }
      }
    }
(5)先序遍历非递归

    void InOrderTraversal(BinTree BT){
      BinTree T=BT;
      Stack s = CreateStack(MaxSize);
      while(T || !IsEmpty(S)){
        while(T){ /*一直向左并将沿途结点压入堆栈*/
          Push(S,T);
          printf("%d",T->Data); /*（访问）打印节点*/
          T=T->Left;
        }
        if(!IsEmpty(S)){
          T=Pop(S); /*结点弹出堆栈*/
          T=T->Right; /*转向右子树*/
        }
      }
    }
(6)后续遍历非递归(双堆栈)

    void PostOrderTraversal(BinTree BT){
      BinTree T=BT;
      Stack S1 = CreateStack(MaxSize);
      Stack S2 = CreateStack(MaxSize);
      while(T || !IsEmpty(S1)|| !IsEmpty(S2)){
        while(T){ /*一直向左并将沿途结点压入堆栈*/
          Push(S1,T);
          T = T->Left;
        }
        if(! IsEmpty(S1)){
          T = Pop(S1) ; /*结点弹出堆栈1*/
          Push(S2,T) ;
          T = T->Right; /*转向右子树*/
        }
        while(!T&&!IsEmpty(S2)){ /*T为空S2不为空*/
          T=Pop(S2); /*结点弹出堆栈*/
          printf("%d",T->Data); /*（访问）打印节点*/
        }
      }

使用2个堆栈，反向做一次遍历，即从T->Right开始，每次需要print的时候就Push到第二的堆栈里，等到遍历结束，再用第二个堆栈实现倒序输出。

    void PostOrderTraversal(BinTree BT){
      BinTree T BT;
      Stack S = CreateStack( Maxsize );
      Stack Q = CreateStack( Maxsize );
      while( T || !IsEmpty( S ) )
      {
          while( T )
          {
              Push( S, T );
              Push( Q, T );//压入第二个栈便于倒序输出
              T = T->Right;
          }
          if( !IsEmpty( S ) )
          {
              T = Pop(S);
              T = T->Left;
          }
      }
      //倒序输出
      while( !IsEmpty( Q ) );
      {
          printf( "%5d", T->Data);
      }
    }
    }
(6)层次遍历(队列)

    void LevelOrderTraversal(BinTree BT){
      Queue Q;
      BinTree T;
      if(!BT) return;
      Q=CreateQueue(MaxSize);
      AddQ(Q,BT);
      while(!IsEmptyQ(Q)){
        T=DeleteQ(Q);
        printf("%d\n",T->Data); /*访问取出队列*/
      }
    }
####2.1.2遍历二插树的应用：
#####2.1.2.1输出二察树中的叶子节点
在二叉树的便利算法中增加检测节点的“左右子树是否都为空”

    void PreOrderPrintLeaves(BinTree BT){
      if(BT){
        if(BT->left && !BT->Right)
          printf("%d",BT->Data);
        PreOrderPrintLeaves(BT->Left);
        PreOrderPrintLeaves(BT->Right);
      }
    }

#####2.1.2.2求二叉树的高度

    int PostOrderGetHeight(BinTree BT){
      int HL,HR,MaxH;
      if(BT){
        HL=PostOrderGetHeight(BT->Left);
        HR=PostOrderGetHeight(BT->Right);
        MaxH=(HL>HR)?HL:HR;
        return (MaxH+1);
      }
      else return 0;
    }
##3.二叉搜索树（动态查找）
###3.1二叉树的查找操作：Find
递归：

    Position Find(ElementType X,BinTree BST){
      if(!BST) return NULL;
      if(X>BST->Data)
        return Find(X,BST->Right);
      else if(X<BST->Data);
        return Find(X,BST->Left);
      else
        return BST;
    }
循环

Position IterFind(ElementType X,BinTree BST){
  while(BST){
    if(X>BST->Data)
      return Find(X,BST->Right);
    else if(X<BST->Data);
      return Find(X,BST->Left);
    else
      return BST;
  }
  return NULL;
}

查找效率取决与书的高度

###3.1二叉树的操作：Find
